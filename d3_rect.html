<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>Lesson1 by Gleb Panteleyev // Rect version</title>
	<!--<link rel="stylesheet" href="resources/lesson1.css">-->
	<style>
		body, html {
			margin: 0;
		}

		h2, fieldset {
			line-height: 0;
			margin-left: 7px;
		}

		fieldset {
			border: 1px solid orange;
		}

		legend {
			color: orange;
		}

		input {
			margin-top: 5px;
		}

		svg {
			margin-top: 5px;
			border-top: 1px dashed lightblue;
		}

		rect, line {
			fill: none;
			stroke-width: 1;
			stroke: black;
		}
	</style>
	<script src="https://d3js.org/d3.v3.min.js" charset="utf-8"></script>
</head>
<body>
<h2>Рисование с помощью прямоугольников</h2>
<fieldset>
	<legend>Настройка сетки</legend>
	В сетке: <input type="number" id="edCntLines" value="10" min="1" max="99"/><sup>2</sup> ячеек<br/>
	Ширина сетки: <input type="number" id="edW" value="400" min="0" max="4000" step="10"/> пикселей<br/>
	Высота сетки: <input type="number" id="edH" value="400" min="0" max="4000" step="10"/> пикселей
</fieldset>
<svg width="100%" height="700"/>
<script>
	d3.select('#edW')
			.on('keyup', setGrid)
			.on('input', setGrid);
	d3.select('#edH')
			.on('keyup', setGrid)
			.on('input', setGrid);
	d3.select('#edCntLines')
			.on('keyup', setGrid)
			.on('input', setGrid);
	d3.select(window)
			.on('resize', setGrid);

	/**
	 * Проверка введенного значения ширины сетки
	 * @param paddingLeft - Отступ слева.
	 * @param paddingRight - Отступ справа.
	 */
	function checkGridWidth(paddingLeft, paddingRight) {
		var objectGridWidth = d3.select('#edW'),
				gridWidth       = parseInt(objectGridWidth.property('value'), 10),
				paddingX        = paddingLeft + paddingRight,
				svgWidth        = d3.select('svg').style('width');

		if (gridWidth < 0)
			objectGridWidth.property('value', 0);
		else if (gridWidth + paddingX > svgWidth)
			objectGridWidth.property('value', svgWidth - paddingX);
	}

	/**
	 * Проверка введенного значения высоты сетки
	 * @param paddingTop - Отступ сыерху.
	 * @param paddingBottom - Отступ снизу.
	 */
	function checkGridHeight(paddingTop, paddingBottom) {
		var objectGridHeight = d3.select('#edH'),
				gridHeight       = parseInt(objectGridHeight.property('value'), 10),
				paddingY         = paddingTop + paddingBottom,
				svgHeight        = d3.select('svg').style('height');

		if (gridHeight < 0)
			objectGridHeight.property('value', 0);
		else if (gridHeight + paddingY > svgHeight)
			objectGridHeight.property('value', svgHeight - paddingY);
	}

	/**
	 * Проверка введенного значения количества линий
	 * @param linesMaxCount - Максимальное количество линий по ширине/ высоте.
	 */
	function checkLinesCount(linesMaxCount) {
		var objectLinesCount = d3.select('#edCntLines'),
				linesCount       = parseInt(objectLinesCount.property('value'), 10);

		if (linesCount < 1)
			objectLinesCount.property('value', 1);
		else if (linesCount > linesMaxCount)
			objectLinesCount.property('value', linesMaxCount);
	}

	/**
	 * Построение сетки
	 */
	function setGrid() {
		const paddingLeft = paddingTop = paddingRight = paddingBottom = 10,				// отступ сетки / для позиционирования
					linesMaxCount = 99;																									// максимальное количество строк/ столбцов

		checkGridWidth(paddingLeft, paddingRight);
		checkGridHeight(paddingTop, paddingBottom);
		checkLinesCount(linesMaxCount);

		var gridWidth  = parseInt(d3.select('#edW').property('value'), 10),					// ширина сетки
				gridHeight = parseInt(d3.select('#edH').property('value'), 10),					// высота сетки
				linesCount = parseInt(d3.select('#edCntLines').property('value'), 10);	// количество строк

		if (!isNaN(gridWidth) && !isNaN(gridHeight) && !isNaN(linesCount)) {
			var cellWidth  = gridWidth / linesCount,																	// ширина ячейки
					cellHeight = gridHeight / linesCount;																	// высота ячейки

			var dataRect = [];

			if (gridWidth > 0 && gridHeight > 0)
				dataRect = d3.range(linesCount * linesCount);

			var rect = d3.select('svg').selectAll('rect').data(dataRect);

			[rect.enter().append('rect'), rect].forEach(el => el.transition().duration(500).attr({
						'transform': i => {
							return 'translate(' + (paddingLeft + i % linesCount * cellWidth) + ', ' + (paddingTop + ~~(i / linesCount) * cellHeight) + ')'
						},
						'width':     cellWidth,
						'height':    cellHeight
					})
			);

			rect.exit().remove();
		}
	}

	setGrid();
</script>
</html>
